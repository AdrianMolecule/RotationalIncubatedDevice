Here is all the current code:
at: 2025-11-05 16:57:01
========================================

--- FILE: BackEnd.h ---

#pragma once

#include <ArduinoJson.h>
#include <ESPAsyncWebServer.h>
#include <ESPmDNS.h>
#include <FS.h>
#include <SPIFFS.h>

#include <vector>

#include "Controller.h"
#include "Field.h"
#include "Helper.h"
#include "JsonWrapper.h"

class BackEnd {
   public:
    static void setupBackend() {
        Serial.println("[SYS] BackEnd Setup complete.");
    }
};
// static void loopBackend() {
//     Serial.println("[SYS] loopBackend Started.");
//     while (true) {
//         if Controller::model.
//         durationSinceRebootInSeconds = millis() / 1000;
//         static unsigned long lastModelUpdateInSeconds = 0;
//         if (durationSinceRebootInSeconds - lastModelUpdateInSeconds >= 5) {
//             lastModelUpdateInSeconds = durationSinceRebootInSeconds;
//             Field* f = model.getByName("duration");
//             if (!f) {
//                 Field nf("10", "duration", "string", String(durationSinceRebootInSeconds), "time since start", false);
//                 model.add(nf);
//             } else
//                 f->setValue(String(durationSinceRebootInSeconds));
//             model.saveToFile();
//             webSocket.textAll(model.toJson());
//         }
//         Field* f = model.getByName("delay");
//         String delayAsString;
//         if (!f) {
//             Field nf("11", "delay", "string", "7", "blocking delay in backend", false);
//             model.add(nf);
//             model.saveToFile();
//             webSocket.textAll(model.toJson());
//             delayAsString = nf.getValue();
//         } else {
//             delayAsString = f->getValue();
//         }
//         int delayAsInt = delayAsString.toInt() * 1000;
//         Serial.println("[BACKEND] Blocking delay " + delayAsString + "s");
//         webSocket.textAll(model.toJson());
//         delay(delayAsInt);
//     }
// }


--- FILE: Controller.h ---

#pragma once
#include <ESPAsyncWebServer.h>

#include "Field.h"
#include "Model.h"

class Controller {
   public:
    inline static Model model = Model{};
    
    inline static AsyncWebSocket webSocket = AsyncWebSocket{"/ws"};
    // ^ Declare the variable here (doesn't allocate memory yet)

    // void incrementCounter() {
    //     global_counter++;  // Access it directly within member functions
    // }
};

--- FILE: Field.cpp ---

#include <ArduinoJson.h>
#include "Field.h"

void Field::fromJson(const JsonObject& obj) {
    id = obj["id"] | "";
    name = obj["name"] | "";
    type = obj["type"] | "";
    value = obj["value"] | "";
    description = obj["description"] | "";
    readOnly = obj["readOnly"] | false;
}

void Field::toJson(JsonObject& obj) const {
    obj["id"] = id;
    obj["name"] = name;
    obj["type"] = type;
    obj["value"] = value;
    obj["description"] = description;
    obj["readOnly"] = readOnly;
}

--- FILE: Field.h ---

#pragma once
#include <Arduino.h>

class Field {
   private:
    String id;
    String name;
    String type;
    String value;
    bool readOnly;
    String description;

   public:
    Field() = default;
    Field(const String& id, const String& name, const String& type = "string",
          const String& value = "0", const String& description = "default description", bool readOnly = false) {
        this->id = id;
        this->name = name;
        this->type = type;
        this->value = value;
        this->description = description;
        this->readOnly = readOnly;
    };
    void fromJson(const JsonObject& obj);
    void toJson(JsonObject& obj) const;
    // Getters
    const String getId() const {
        return id;
    }
    const String getName() const {
        return name;
    }
    const String getType() const { return type; }
    const String getValue() const { return value; }
    bool getReadOnly() const { return readOnly; }
    const String getDescription() const { return description; }

    // Setters with logging
    void setValue(const String& val) {
        Serial.printf("[Field] %s setValue: %s -> %s\n", name.c_str(), value.c_str(), val.c_str());
        value = val;
    }

    void setName(const String& val) {
        Serial.printf("[Field] setName: %s -> %s\n", name.c_str(), val.c_str());
        name = val;
    }

    void setId(const String& val) {
        Serial.printf("[Field] setId: %s -> %s\n", id.c_str(), val.c_str());
        id = val;
    }

    void setType(const String& val) {
        Serial.printf("[Field] setType: %s -> %s\n", type.c_str(), val.c_str());
        type = val;
    }

    void setReadOnly(bool val) {
        Serial.printf("[Field] setReadOnly: %d -> %d\n", readOnly, val);
        readOnly = val;
    }

    void setDescription(const String& val) {
        Serial.printf("[Field] setDescription: %s -> %s\n", description.c_str(), val.c_str());
        description = val;
    }
};


--- FILE: Helper.h ---

#pragma once
#include <Arduino.h>
#include <time.h>

const String NOT_PRESENT = String("255");
uint8_t maxHeaterDutyCyclePercentage;
int currentStepsPerRotation;
unsigned long currentStartTime;  // time since ESP power on in millis

class Helper {
   public:
    Helper() = default;
    static void initialize(std::vector<Field>& fields) {
        int idCounter = 0;
        // desired or set values
        fields.emplace_back(String(idCounter++), "desiredTemperature", "float", "37", "desired Temperature");
        fields.emplace_back(String(idCounter++), "currentTemperature", "float", "-1", "current Temperature", true);
        fields.emplace_back(String(idCounter++), "currentRPM", "float ", "300", "current RPM");
        fields.emplace_back(String(idCounter++), "currentHeatingEndDurationInMinutes", "unsigned long ", NOT_PRESENT, "currentHeatingEndDurationInMinutes", false);
        // pins
        fields.emplace_back(String(idCounter++), "HeaterPin", "uint8_t ", NOT_PRESENT, "Heater Pin", false);
        fields.emplace_back(String(idCounter++), "HeaterPwmChannel", "uint8_t ", NOT_PRESENT, "HeaterPwmChannel");
        fields.emplace_back(String(idCounter++), "StepperPwmStepPin", "uint8_t ", String(25), "StepperPwmStepPin");
        fields.emplace_back(String(idCounter++), "StepperPwmChannel", "uint8_t ", String(2), "StepperPwmChannel");
        fields.emplace_back(String(idCounter++), "StepperEnablePin", "uint8_t ", String(26), "StepperEnablePin");
        fields.emplace_back(String(idCounter++), "I2SoClockPin", "uint8_t ", NOT_PRESENT, "I2SoClockPin");
        fields.emplace_back(String(idCounter++), "I2SoLatchPin", "uint8_t ", NOT_PRESENT, "I2SoLatchPin");
        fields.emplace_back(String(idCounter++), "LedPin", "uint8_t ", String(2), "LedPin");
        fields.emplace_back(String(idCounter++), "PotentiometerPin", "uint8_t ", NOT_PRESENT, "PotentiometerPin");
        fields.emplace_back(String(idCounter++), "TempSensorPin", "uint8_t ", NOT_PRESENT, "TempSensorPin");
        fields.emplace_back(String(idCounter++), "SpeakerPin", "uint8_t ", String(12), "SpeakerPin");
        fields.emplace_back(String(idCounter++), "SpeakerChannel", "uint8_t ", String(4), "SpeakerChannel");
        fields.emplace_back(String(idCounter++), "FanPin", "uint8_t ", NOT_PRESENT, "FanPin");
        fields.emplace_back(String(idCounter++), "FanPwmChannel", "uint8_t ", NOT_PRESENT, "FanPwmChannel");
        fields.emplace_back(String(idCounter++), "MemoryCsPin", "uint8_t ", NOT_PRESENT, "MemoryCsPin");
        fields.emplace_back(String(idCounter++), "SpindleEnablePin", "uint8_t ", NOT_PRESENT, "SpindleEnablePin");
        // misc
        fields.emplace_back(String(idCounter++), "UseOneWireForTemperature", "bool", "0", "UseOneWireForTemperature");
        fields.emplace_back(String(idCounter++), "MKSBoard", "bool", "0", "MKSBoard");
        // Preferences
        fields.emplace_back(String(idCounter++), "preference_TimeDisplay", "bool", "1", "preference_TimeDisplay");
        fields.emplace_back(String(idCounter++), "preference_TemperatureDisplay", "bool", "1", "preference_TemperatureDisplay");
        fields.emplace_back(String(idCounter++), "preference_MostMusic_OFF", "bool", "0", "preference_MostMusic_OFF");
        fields.emplace_back(String(idCounter++), "preference_TemperatureReached_MusicOn", "bool", "1", "preference_TemperatureReached_MusicOn");
        // Debug Flags
        fields.emplace_back(String(idCounter++), "DEBUG_HEATER", "bool", "1", "DEBUG_HEATER");
        fields.emplace_back(String(idCounter++), "DEBUG_FAN", "bool", "1", "DEBUG_FAN");
        fields.emplace_back(String(idCounter++), "DEBUG_SWITCH", "bool", "1", "DEBUG_SWITCH");
        fields.emplace_back(String(idCounter++), "LowHumidityAlert", "bool", "1", "Alert if LowHumidity detected, works only when we sue DH not UseOneWireForTemperature");
        fields.emplace_back(String(idCounter++), "VERSION", "string", "1.1", "Version", true);
        uint8_t maxHeaterDutyCyclePercentage;
        int currentStepsPerRotation;
        unsigned long currentStartTime;  // time since ESP power on in millis
    }
    static void initializeSample(std::vector<Field>& fields) {
        int idCounter = 0;
        // desired or set values
        fields.emplace_back(String(idCounter++), "a", "float", "37", "desired Temperature");
        fields.emplace_back(String(idCounter++), "b", "int", "0", "b");
        fields.emplace_back(String(idCounter++), "VERSION", "string", "1.1", "Version", true);
    }

    static String getTime() {
        struct tm timeinfo;
        // getLocalTime fills the 'timeinfo' structure.
        // It returns true on success, false on failure (e.g., no Wi-Fi/NTP sync issue)
        if (!getLocalTime(&timeinfo)) {
            return "Failed to obtain time";
        }
        // A buffer is required to hold the formatted C-style string temporarily
        char buffer[80];
        strftime(buffer, sizeof(buffer), "%A, %b %d %Y %I:%M:%S %p", &timeinfo);
        return String(buffer);
    }
};


--- FILE: JsonWrapper.cpp ---

#include "JsonWrapper.h"
#include <SPIFFS.h>

const char* FILE_LOCATION = "/model.json";
String JsonWrapper::toJsonString(const std::vector<Field>& fields) {
    JsonDocument doc;  // sufficient size for fields
    JsonArray arr = doc.to<JsonArray>();
    for (const auto& f : fields) {
        JsonObject obj = arr.add<JsonObject>();
        obj["id"] = f.getId();
        obj["name"] = f.getName();
        obj["type"] = f.getType();
        obj["value"] = f.getValue();
        obj["description"] = f.getDescription();
        obj["readOnly"] = f.getReadOnly();
    }
    String result;
    serializeJson(doc, result);
    return result;
}

String JsonWrapper::fieldToJsonString(const Field& f) {
    JsonDocument doc;
    JsonObject obj = doc.to<JsonObject>();
    obj["id"] = f.getId();
    obj["name"] = f.getName();
    obj["type"] = f.getType();
    obj["value"] = f.getValue();
    obj["description"] = f.getDescription();
    obj["readOnly"] = f.getReadOnly();
    String result;
    serializeJson(doc, result);
    return result;
}

bool JsonWrapper::jsonToField(const String& jsonStr, Field& f) {
    JsonDocument doc;
    auto error = deserializeJson(doc, jsonStr);
    if (error) return false;
    JsonObject obj = doc.as<JsonObject>();
    f.setId(obj["id"] | "");
    f.setName(obj["name"] | "");
    f.setType(obj["type"] | "");
    f.setValue(obj["value"] | "");
    f.setDescription(obj["description"] | "");
    f.setReadOnly(obj["readOnly"] | false);

    return true;
}

bool JsonWrapper::jsonToFields(const String& jsonStr, std::vector<Field>& fields) {
    JsonDocument doc;
    auto error = deserializeJson(doc, jsonStr);
    if (error) return false;
    JsonArray arr = doc.as<JsonArray>();
    fields.clear();
    for (JsonObject obj : arr) {
        Field f;
        f.setId(obj["id"] | "");
        f.setName(obj["name"] | "");
        f.setType(obj["type"] | "");
        f.setValue(obj["value"] | "");
        f.setDescription(obj["description"] | "");
        f.setReadOnly(obj["readOnly"] | false);
        fields.push_back(f);
    }
    return true;
}

String JsonWrapper::deleteFieldJson(const String& id) {
    JsonDocument doc;
    JsonObject obj = doc.to<JsonObject>();
    obj["action"] = "delete";
    obj["id"] = id;
    String s;
    serializeJson(doc, s);
    return s;
}

String JsonWrapper::updateFieldJson(const Field& f) {
    JsonDocument doc;
    JsonObject obj = doc.to<JsonObject>();
    obj["action"] = "update";
    obj["id"] = f.getId();
    obj["value"] = f.getValue();
    String s;
    serializeJson(doc, s);
    return s;
}

bool JsonWrapper::saveModelToFile(const std::vector<Field>& fields) {
    File file = SPIFFS.open(FILE_LOCATION, FILE_WRITE);
    if (!file) {
        Serial.println("Error when trying to open the saveto file. Maybe the location of:" + String(FILE_LOCATION)+ " is not correct or possible");
        return false;
    }
    String s = toJsonString(fields);
    file.print(s);
    file.close();
    return true;
}

bool JsonWrapper::loadFieldsFromFile(std::vector<Field>& fields) {
    if (!SPIFFS.begin(true)) return false;
    if (!SPIFFS.exists(FILE_LOCATION)) return false;
    File file = SPIFFS.open(FILE_LOCATION, FILE_READ);
    if (!file) return false;
    String s = file.readString();
    file.close();
    return jsonToFields(s, fields);
}


--- FILE: JsonWrapper.h ---

#pragma once
#include <ArduinoJson.h>
#include <vector>
#include "Field.h"

class JsonWrapper {
   public:
    // Convert vector of Fields → JSON string
    static String toJsonString(const std::vector<Field>& fields);

    // Convert a single Field → JSON string
    static String fieldToJsonString(const Field& f);

    // Parse JSON string → single Field
    static bool jsonToField(const String& jsonStr, Field& f);

    // Parse JSON string → vector<Field>
    static bool jsonToFields(const String& jsonStr, std::vector<Field>& fields);

    // Generate JSON for delete action
    static String deleteFieldJson(const String& id);

    // Generate JSON for update action
    static String updateFieldJson(const Field& f);

    // Save fields to SPIFFS file
    static bool saveModelToFile(const std::vector<Field>& fields);

    // Load fields from SPIFFS file
    static bool loadFieldsFromFile( std::vector<Field>& fields);
};


--- FILE: mainJustFieldsWorks.cpp ---

#include <ArduinoJson.h>
#include <ESPAsyncWebServer.h>
#include <ESPmDNS.h>
#include <FS.h>
#include <SPIFFS.h>
#include <WiFi.h>

#include <vector>

#include "BackEnd.h"
//#include "Controller.h"
#include "Field.h"
#include "Helper.h"
#include "JsonWrapper.h"
#include "Model.h"
#include "pass.h"

AsyncWebServer server(80);            // needs to persist beyond the method
AsyncWebSocket webSocket = AsyncWebSocket{"/ws"};
Model model;

String generateMenu() { return "<p><a href='/'>Index</a> | <a href='/info'>Info</a> | <a href='/metadata'>Metadata</a> | <a href='/debug'>Debug</a> | <a href='/reboot'>Reboot</a></p>"; }

String generateIndexPage(bool brief) {
    String html = generateMenu();
    if (brief) {
        html += "<h1>Index Page</h1>";
    } else {
        html += "<h1>Info Page</h1>";
    }
    html += "<table border=1><tr><th>Name</th><th>Type</th><th>Value</th><th>Description</th></tr>";
    for (auto& f : model.getFields()) {
        if (!brief && f.getReadOnly()) continue;
        html += "<tr><td>" + f.getName() + "</td><td>" + f.getType() + "</td>";
        if (f.getReadOnly())
            html += "<td><input value='" + f.getValue() + "' disabled></td>";
        else
            html += "<td><input data-id='" + f.getId() + "' value='" + f.getValue() + "' onchange='onChange(this)'></td>";
        html += "<td>" + f.getDescription() + "</td></tr>";
    }
    html += R"(<script>
    var ws = new WebSocket('ws://' + location.hostname + '/ws');
    ws.onmessage = function(evt) {
        try {
            var data = JSON.parse(evt.data);
            if (!Array.isArray(data)) return;
            data.forEach(f => {
                var el = document.querySelector("input[data-id='" + f.id + "']");
                if (el) 
                el.value = f.value;
                });
                } catch(e) {
                    console.error("WS update error:", e);
                    }
                    };
                    function onChange(el){
                        var val = el.value;
                        var id = el.getAttribute('data-id');
                        ws.send(JSON.stringify({action:'update',id:id,value:val}));
                        }
                        </script>)";
    return html;
}
String generateMetadataPage() {
    String html;
    html += "<h1>Metadata</h1>";
    html += "<p><a href='/'>Index</a> | <a href='/info'>Info</a> | <a href='/debug'>Debug</a></p>";
    html += "<table border=1><thead><tr><th>Id</th><th>Name</th><th>Type</th><th>Value</th><th>Description</th><th>ReadOnly</th><th>Reorder</th><th>Delete</th></tr></thead><tbody id='meta-body'>";
    for (auto& f : model.getFields()) {
        html += "<tr>";
        html += "<td>" + f.getId() + "</td>";
        html += "<td>" + f.getName() + "</td>";
        html += "<td>" + f.getType() + "</td>";
        html += "<td>" + f.getValue() + "</td>";
        html += "<td>" + f.getDescription() + "</td>";
        html += "<td>" + String(f.getReadOnly()) + "</td>";
        html += "<td><button onclick='reorder(\"" + f.getId() + "\",true)'>&#9650;</button><button onclick='reorder(\"" + f.getId() + "\",false)'>&#9660;</button></td>";
        html += "<td><button onclick='delField(\"" + f.getId() + "\")'>Delete</button></td>";
        html += "</tr>";
    }
    html += "</tbody></table>";
    html += "<h3>Add New Field</h3>";
    html += "ID: <input id='fid'><br>";
    html += "Name: <input id='fname'><br>";
    html += "Type: <input id='ftype'><br>";
    html += "Value: <input id='fvalue'><br>";
    html += "Description: <input id='fdesc'><br>";
    html += "ReadOnly: <input id='freadonly' type='checkbox'><br>";
    html += "<button onclick='addField()'>Add Field</button>";
    html += R"rawliteral(
                            <script>
                            var ws = new WebSocket('ws://' + location.hostname + '/ws');
                            ws.onmessage = function(evt){
    try{
        var data = JSON.parse(evt.data);
        if(!Array.isArray(data)) return;
        var tbody = document.querySelector('#meta-body');
        if(!tbody) return;
        tbody.innerHTML = "";
        data.forEach(f=>{
            var row = document.createElement("tr");
            row.innerHTML =
            "<td>"+f.id+"</td>"+
            "<td>"+f.name+"</td>"+
            "<td>"+f.type+"</td>"+
            "<td>"+f.value+"</td>"+
            "<td>"+f.description+"</td>"+
            "<td>"+f.readOnly+"</td>"+
            "<td><button onclick='reorder(\""+f.id+"\",true)'>&#9650;</button>"+
            "<button onclick='reorder(\""+f.id+"\",false)'>&#9660;</button></td>"+
            "<td><button onclick='delField(\""+f.id+"\")'>Delete</button></td>";
            tbody.appendChild(row);
            });
            }catch(e){console.error(e);}
            };
            function delField(id){ws.send(JSON.stringify({action:'delete',id:id}));}
            function reorder(id,up){ws.send(JSON.stringify({action:up?'moveUp':'moveDown',id:id}));}
            function addField(){
                var fid=document.getElementById('fid').value.trim();
                if(!fid){
                    var maxId=0;
                    document.querySelectorAll('#meta-body tr td:first-child').forEach(td=>{
                        var n=parseInt(td.innerText);
                        if(!isNaN(n)&&n>maxId) maxId=n;
                        });
        fid=(maxId+1).toString();
        document.getElementById('fid').value=fid;
    }
    var msg={action:'add',field:{
        id:fid,
        name:document.getElementById('fname').value,
        type:document.getElementById('ftype').value,
        value:document.getElementById('fvalue').value,
        description:document.getElementById('fdesc').value,
        readOnly:document.getElementById('freadonly').checked
        }};
        ws.send(JSON.stringify(msg));
        // clear inputs after sending
        document.getElementById('fid').value="";
        document.getElementById('fname').value="";
        document.getElementById('ftype').value="";
        document.getElementById('fvalue').value="";
        document.getElementById('fdesc').value="";
        document.getElementById('freadonly').checked=false;
        }
        </script>
        )rawliteral";

    return html;
}

String generateDebugPage() { return generateMenu() + "<h1>Debug</h1><pre>" + model.toJsonString() + "</pre>"; }

void handleWebSocketMessage(String msg) {  // from the UI
    JsonDocument doc;
    Model m = model;
    if (deserializeJson(doc, msg)) return;
    String action = doc["action"] | "";
    if (action == "update") {
        String id = doc["id"] | "";
        String val = doc["value"] | "";
        Field* f = model.getById(id);
        if (f && !f->getReadOnly()) {
            f->setValue(val);
            model.saveToFile();
            webSocket.textAll(model.toJsonString());
        }
    } else if (action == "delete") {
        String id = doc["id"] | "";
        if (model.remove(id)) {
            model.saveToFile();
            webSocket.textAll(model.toJsonString());
        }
    } else if (action == "moveUp" || action == "moveDown") {
        String id = doc["id"] | "";
        model.reorder(id, action == "moveUp");
        model.saveToFile();
        webSocket.textAll(model.toJsonString());
    } else if (action == "add") {
        JsonObject fld = doc["field"].as<JsonObject>();
        Field f;
        f.fromJson(fld);
        model.add(f);
        model.saveToFile();
        webSocket.textAll(model.toJsonString());
    }
}

// NTP Server settings
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = -18000;    // Set your GMT offset in seconds (e.g., EST is -5 hours * 3600 seconds/hour = -18000)
const int daylightOffset_sec = 3600;  // Set your daylight saving offset in seconds (e.g., 1 hour = 3600 seconds)
void setup() {
    Serial.begin(115200);
    Serial.println("[SYS] Booting...");
    WiFi.begin(getSsid(), getPass());
    Serial.printf("[WiFi] Connecting to %s ", getSsid());
    int timeout = 0;
    while (WiFi.status() != WL_CONNECTED && timeout < 20) {
        delay(500);
        Serial.print(".");
        timeout++;
    }
    Serial.println();
    if (WiFi.status() == WL_CONNECTED) {
        Serial.printf("[WiFi] Connected! IP: %s\n", WiFi.localIP().toString().c_str());
        // Initialize and get the time from NTP server
        configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);

        Serial.println(" at:" + Helper::getTime());
        if (MDNS.begin("bio"))
            Serial.println("[mDNS] Registered as bio.local");
        else
            Serial.println("[mDNS] Failed to start mDNS");
    } else
        Serial.println("[WiFi] Connection failed!");
    if (!SPIFFS.begin(false))
        Serial.println("[FS] Mount failed!");
    else
        Serial.println("[FS] Mounted successfully.");
    // TODO stop everyhing if no SPIFF
    model.initializeSample();
    Serial.println("model object created and content is:" + model.toBriefJsonString());
    // Serial.println(Controller::webSocket.url());
    // Serial.println("webSocket object created");
    server.on("/", HTTP_GET, [](AsyncWebServerRequest* r) { r->send(200, "text/html", generateIndexPage(true)); });
    server.on("/info", HTTP_GET, [](AsyncWebServerRequest* r) { r->send(200, "text/html", generateIndexPage(false)); });
    server.on("/metadata", HTTP_GET, [](AsyncWebServerRequest* r) { r->send(200, "text/html", generateMetadataPage()); });
    server.on("/debug", HTTP_GET, [](AsyncWebServerRequest* r) { r->send(200, "text/html", generateDebugPage()); });
    server.on("/reboot", HTTP_GET, [](AsyncWebServerRequest* r) {r->send(200,"text/plain","Rebooting...");delay(100);ESP.restart(); });

    // AsyncWebSocket w = Controller::webSocket;
    webSocket.onEvent([](AsyncWebSocket* server, AsyncWebSocketClient* client, AwsEventType type, void* arg, uint8_t* data, size_t len) {if(type==WS_EVT_DATA){String msg;for(size_t i=0;i<len;i++)msg+=(char)data[i];handleWebSocketMessage(msg);} });
    server.addHandler(&webSocket);
    server.begin();
    // BackEnd::setupBackend();
    //  xTaskCreatePinnedToCore([](void*) { BackEnd::loopBackend(); }, "BackendTask", 4096, nullptr, 1, nullptr, 1);
    Serial.println("[SYS] Setup complete.");
}

bool first = true;
void loop() {
    // AsyncWebSocket w = Controller::webSocket;
    if (first) {
        Serial.println("Model m = model;");
        //Serial.println("AsyncWebSocket w = Controller::webSocket;");
        Serial.println("in loop brief model via Controller is:" + model.toBriefJsonString());
        Serial.println("in loop brief model via m is:" + model.toBriefJsonString());
        first = false;
    }
    if (Serial.available()) {
        String line = Serial.readStringUntil('\n');
        line.trim();
        if (line == "m")
            model.listSerial();
        else if (line == "j")
            Serial.println(model.toJsonString());
        else if (line.startsWith("upload ")) {
            String jsonStr = line.substring(line.indexOf(' ') + 1);
            jsonStr.trim();
            if (JsonWrapper::jsonToFields(jsonStr, model.getFields())) {
                JsonWrapper::saveModelToFile(model.getFields());
                Serial.println("New replaced Json:" + String(model.toJsonString()));
            } else {
                Serial.println("New entered Json does not parse so Model remained unchanged");
            }
            webSocket.textAll(model.toJsonString());
        } else if (line.startsWith("add ")) {
            Field f;
            f.setReadOnly(false);
            int idx;
            idx = line.indexOf("name=");
            if (idx >= 0) {
                int e = line.indexOf(" ", idx);
                if (e < 0) e = line.length();
                f.setName(line.substring(idx + 5, e));
            }
            idx = line.indexOf("id=");
            if (idx >= 0) {
                int e = line.indexOf(" ", idx);
                if (e < 0) e = line.length();
                f.setId(line.substring(idx + 3, e));
            } else {
                Serial.println("TODO should default the id if not present int the field");
            }
            idx = line.indexOf("type=");
            if (idx >= 0) {
                int e = line.indexOf(" ", idx);
                if (e < 0) e = line.length();
                f.setType(line.substring(idx + 5, e));
            }
            idx = line.indexOf("value=");
            if (idx >= 0) {
                int e = line.indexOf(" ", idx);
                if (e < 0) e = line.length();
                f.setValue(line.substring(idx + 6, e));
            }
            idx = line.indexOf("description=");
            if (idx >= 0) {
                int e = line.indexOf(" ", idx);
                if (e < 0) e = line.length();
                f.setDescription(line.substring(idx + 12, e));
            }
            idx = line.indexOf("readonly=");
            if (idx >= 0) {
                f.setReadOnly((line.substring(idx + 9, idx + 10) == "1"));
            }
            if (f.getName() != "") {
                model.add(f);
                model.saveToFile();
                webSocket.textAll(model.toJsonString());
            }
        } else if (line.startsWith("delete ")) {
            String name = line.substring(7);
            Field* f = model.getByName(name);
            if (f) {
                model.remove(f->getId());
                Serial.printf("[SERIAL] Deleted field  %s\n", name.c_str());
                model.saveToFile();
                webSocket.textAll(model.toJsonString());
            }
        } else if (line.startsWith("r")) {
            model.initialize();
            Serial.printf("[SERIAL] Reinitialized the whole model");
        } else if (line.startsWith("?")) {
            Serial.println("\n--- Available Serial Commands ---");
            Serial.println("? or help          : Display this help message");
            Serial.println("m                  : List current model fields details");
            Serial.println("j                  : Print full model as JSON string");
            Serial.println("upload <json_str>  : Replace entire model with new JSON data");
            Serial.println("add name=... id=...: Add a new field (supply all params)");
            Serial.println("delete <name>      : Delete a field by name");
            Serial.println("<name>=<value>     : Update the value of an existing field");
            Serial.println("r                  : reset reinitialize fields with factory setting");
            Serial.println("-----------------------------------\n");
        } else {
            int eq = line.indexOf('=');
            if (eq > 0) {
                String name = line.substring(0, eq);
                String val = line.substring(eq + 1);
                Field* f = model.getByName(name);
                if (f && !f->getReadOnly()) {
                    f->setValue(val);
                    model.saveToFile();
                    Serial.printf("[SERIAL] Updated %s = %s\n", f->getName().c_str(), f->getValue().c_str());
                    webSocket.textAll(model.toJsonString());
                }
            }
        }
    }
}


--- FILE: Model.h ---

#pragma once
#include "Field.h"
#include "Helper.h"
#include "JsonWrapper.h"

class Model {
   private:
    std::vector<Field> fields;

   public:
    std::vector<Field>& getFields() {
        return fields;
    }

    Field* getById(const String& id) {
        for (auto& f : fields)
            if (f.getId() == id) return &f;
        return nullptr;
    }

    Field* getByName(const String& name) {
        for (auto& f : fields)
            if (f.getName() == name) return &f;
        return nullptr;
    }

    void add(Field f) {
        fields.push_back(f);
        Serial.println("[Model] added field " + f.getName());
    }

    bool remove(const String& id) {
        for (size_t i = 0; i < fields.size(); i++) {
            if (fields[i].getId() == id) {
                fields.erase(fields.begin() + i);
                return true;
                Serial.println("{Model] removed field " + fields[i].getName());
            }
        }
        return false;
    }

    void reorder(const String& id, bool up) {
        for (size_t i = 0; i < fields.size(); i++) {
            if (fields[i].getId() == id) {
                if (up && i > 0)
                    std::swap(fields[i], fields[i - 1]);
                else if (!up && i < fields.size() - 1)
                    std::swap(fields[i], fields[i + 1]);
                break;
            }
        }
    }

    void initialize() {
        Serial.println("[MODEL] Initialize model by loading factory model");
        Helper::initialize(fields);
    }

    void initializeSample() {
        Serial.println("[MODEL] Initialize just SAMPLE model by loading factory model");
        Helper::initializeSample(fields);
    }

    bool load() {
        JsonWrapper::loadFieldsFromFile(fields);
        if (fields.empty()) {
            initialize();
            return false;
        }
        return true;
    }

    bool saveToFile() {
        File file = SPIFFS.open("/model.json", "w");
        if (!file) {
            Serial.println("error in model saveToFile file");
            return false;
        }
        return JsonWrapper::saveModelToFile(fields);
    }

    String toJsonString() {
        return JsonWrapper::toJsonString(fields);
    }
    String toBriefJsonString() {
        String result = "Brief for Fields size:" + String(fields.size());
        if (fields.size() >= 2) {
            result += ", " + fields.at(0).getName() + " ,";
            result += fields.at(fields.size() - 1).getName();
        }
        return result;
    }

    void listSerial() {
        for (auto& f : fields) Serial.printf("%s (%s) = %s\n", f.getName().c_str(), f.getType().c_str(), f.getValue().c_str());
    }
};  // end Model


--- FILE: pass.h ---

#ifndef Pass_H_
#define Pass_H_
#include <ArduinoJson.h>

const char* jsonString = "{\"ssid\":\"ad5\", \"password\":\"S1tormy!\"}";
  JsonDocument doc;
const char * getSsid(){
  DeserializationError error = deserializeJson(doc, jsonString);
  if (error) {
      Serial.print(F("deserializeJson() failed: "));
      Serial.println(error.f_str());
      return "";
  } else {
      return doc["ssid"];
  }
}
const char * getPass(){
  DeserializationError error = deserializeJson(doc, jsonString);
  if (error) {
      Serial.print(F("deserializeJson() failed: "));
      Serial.println(error.f_str());
      return "";
  } else {
      return doc["password"];
  }
}
#endif /* Pass_H_ */
#pragma once

